---
title: PUP Purpose and Guidelines
author: Brian Bouterse
---

Summary
=======

This proposal provides a structured process to propose, track, discuss, and decide on process
changes for the Pulp project and community.

Motivation
==========

As initially [raised on the pulp-dev list](https://www.redhat.com/archives/pulp-dev/2017-February/msg00014.html),
Pulp lacks a process to propose, track, discuss, and decide on changes that affect the Pulp
community.

This is a problem that has been addressed by many communities. The process outlined in this document
is inspired by processes in the Python, Django, and Foreman communities.


What are these called?
======================

We need an acronym or initialization for these. Here are some quick ideas:

* "Pulp Update Proposal" (PUP)
* "Pulp Change Proposal" (PCP)
* <Your idea here>


Tracking Proposals
==================

Proposals would be in restructured text format and sent as a pull request against the
pulpproject.org repo or a dedicated repo. We could easily create a tab at the top of pulpproject.org
to show off merged proposals. This could also be in a separate, dedicated repo like Python does, but
for simplicity I'm modeling this using the pulpproject.org repo. The idea to render proposals is
similar to how [Python Enhancement Proposals (PEPs)](https://www.python.org/dev/peps/pep-0001/)
work, which are markdown documents that are also viewable/readable as rendered documents via a
browser.


Finding/Discovering Proposals
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

An index mimicking [the Python one](https://www.python.org/dev/peps/) would be created which would
show all proposals in different states (active, approved, rejected, abandoned). These would also be
viewable via pulpproject.org in a dedicated area.


Proposal Process
================

The overall process is: Pre-proposal -> Authoring -> Announcement ->  Discussion and Feedback ->
Revision -> Voting -> Decision

Most of the process is facilitated using either the pulp-list or pulp-dev mailing lists. The
following guidelines identify how they should.

* For changes impacting users, [pulp-list](https://www.redhat.com/mailman/listinfo/pulp-list) is the
  appropriate place.
* For changes impacting developers, [pulp-dev](https://www.redhat.com/mailman/listinfo/pulp-dev) is
  the appropriate place.

Pre-Proposal
^^^^^^^^^^^^

Discussing an idea via the appropriate mailing list prior to writing a formal proposal is
encouraged. This is intended to save the author time by gathering feedback quickly before writing a
concrete, detailed proposal.


Authoring
^^^^^^^^^

One or more authors create the proposal as a pull request against
[the pulpproject.org repo](http://github.com/pulp/pulpproject.org/) using the next sequential
proposal number. The proposal is a single file, e.g. `pup-0022.rst`. A core dev is expected to
merge any proposal with adequate clarity and in the expected format.


Announcement
^^^^^^^^^^^^

Once a proposal is merged to the proposals area, an announcement would be sent to the appropriate
list, which would include a very brief introduction and a link to the proposal in its web viewable
form.


Discussion and Feedback
^^^^^^^^^^^^^^^^^^^^^^^

General discussion would occur on the announcement thread on the appropriate mailing list. Threaded
e-mail readers should make this conversation format easy to follow, while keeping the proposal
document in-tact and easy to read.


Revision
^^^^^^^^

Revision would occur as additional pull requests against the active proposal. This allows the
changelog of a proposal to always be maintained. This is how Python does it. This also allows
edits/updates to come with a commit message indicating the concerns addressed or improvements
including links to responses via the archive. Collaboration is also easy with a collaborator sending
revisions to the author as a patch or a new pull request against the proposal.


Voting
^^^^^^

The +1, +0, -0, -1 feedback process is used, with votes sent as responses via the
announcement/discussion mailing list. The voting has the following meanings:

* +1: "I love the idea and I’m strongly committed to it."
* +0: "Sounds OK to me."
* -0: "I’m not thrilled, but I won’t stand in the way."
* -1: "I strongly disagree and would be very unhappy to see the idea turn into reality." This type
  of feedback must come with a statement of objective concerns explaining what harm will come from
  adopting the proposal. Also, -1 feedback should not be used to express subjective preferences.

Note that votes can come from anyone, not just core devs. This is directly modeled after [the
Django process](https://docs.djangoproject.com/en/dev/internals/contributing/bugs-and-features/#how-we-make-decisions)
who modeled their process after the Python and Apache communities.


Deciding
^^^^^^^^

* If an obvious consensus arises via voting, the proposal is ratified. This is a bit vague, but it
  works for the Django community.
* Discussion on the thread can confirm if consensus is obvious or not.
* Votes come from anyone, not just core devs
* A -1 from a core dev is considered a veto vote and will block ratification until the vote is
  recast.
* Core devs are expected to consider and echo serious feedback from the community especially any -1
  votes from community members.
* Consensus is not always possible. If obvious consensus is not reached, then the core devs decide.


Proposal Requirements
=====================

This is a modified version of [the Foreman template](https://github.com/theforeman/rfcs/blob/master/0000-template.md).

::

    ---
    title: <title goes here>
    author: <author or authors named>
    ---

    Summary
    =======

    One paragraph explanation of the feature.


    Motivation
    ==========

    Why are we doing this? What problem is it designed to solve? What is the expected outcome?


    Detailed Design
    ===============

    This is the bulk of the RFC. Explain the design in enough detail for somebody familiar with the
    project to understand, and for somebody familiar with the codebase to implement. This should get
    into specifics and corner cases, and include examples of how the feature is used.


    Drawbacks
    =========

    Why should we not do this?


    Alternatives
    ============

    What other designs have been considered? What is the impact of not doing this?


    Unresolved Questions
    ====================

    What parts of the design are still TBD?


Reaching a Decision
===================

How Long?
^^^^^^^^^

The initial announcement needs to identify a must-respond-by date and time. This should be no less
than 10 calendar days from the initial announcement. Longer periods are also OK, and can be adjusted
via the list based on feedback via the list. I think using calendar days is better than business
days because the whole world treats calendar days the same. I suggest 10 because sometimes people go
offline for a whole week. Longer than 10 days and I think the process could become too slow.


Why Approve/Reject This Way?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* It treats community decision making (not just core dev decision making) as a first class principle
* It works for the best communities we know of (Django, Python, Apache, etc)
* It allows people to be as involved or not as they way
* It allows serious concerns to not be dismissed (due to a -1 veto vote from core dev)


Approval
^^^^^^^^

* The proposal index is updated moving it from an active section to an approved area. This is
  similar to the index of PEPs for Python.
* A post-approval announcement should be sent in the same thread as the initial announcement and
  discussion, preferably with the link to the approved proposal visible via pulpproject.org


Rejected or Abandoned Proposals
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* They are moved in the index from the active section to the rejected or abandoned sections.
* The proposal text stays committed and is not removed.


Is This Replacing Story Planning in Redmine?
============================================

No. This is for changes to process and should not be used to discuss the feature set or bugs of
Pulp. Feature and bug discussion would continue to occur as-is (on pulp.plan.io). Two recent-ish
examples of things which could have gone through this process include "Napoleon docstrings or not?",
"To Merge forward or not?".

This is different than the communities we are modeling our process after. They use it for feature
planning also, but I propose that we don't do that currently.


Examples
========

* This proposal
* All the PEPs in both [web](https://www.python.org/dev/peps/) and
  [raw](https://github.com/python/peps) form.


Drawbacks
=========

* The history is in two places: the commit history and separately the mailing list archive.
* Initial creation and revisions require merging by a core dev versus having it live as a PR at all
  times.
* Mailing lists can be hard to follow.


Alternatives
============

We could store the PEPs in Redmine. Why aren't we using Redmine?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Upsides:

* It would keep every comment and the proposal itself on one webpage.
* It would be kept along with bugs and stories

Downsides:

* Redmine isn't great for long, structured documents. For instance linking between sections is hard.
* Redmine's long conversations become difficult to read
* Comments don't support threading well.
* History of Redmine edits is not as clear as a git commit history.
* Not as beautiful as a web-viewable archive of decisions


What about leaving it as a pull request for longer?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Upsides:

* Anyone can create and maintain a proposal with complete self-service until it needs to be merged.

Downsides:

* This is very developer focused. Everyone knows how use emails and a web browser. Not everyone
  knows how to use Github review.
* The proposal never being merged to a Pulp repo may cause us to loose access to previous proposals.
* Maintaining a numbered record of Proposals is more difficult.


What about using Github for discussion?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Upsides:

* It keeps comments in one place, with the proposal document
* You can leave comments line-by-line
* It supports threading pretty well
* You could use github voting.

Downside:

* This is very developer focused. Everyone knows how use emails and a web browser. Not everyone
  knows how to use Github review.
* It breaks up the document which makes it practically less readable
* It can be hard to see comments over time with new versions collapsing the comments when they
  become "outdated".


Unresolved Questions
====================

What are we calling it? (PUP, PCP, <your idea here>)
Is 10 calendar days the right decision making time default.
